***( Thoughts:
- Not sure how to deal with the sort K:
  Is it a super syntactic category of everything, with actual injections into
  it from each other user-defined syntactic category, or consider it a special
  sort where each user-defined sort is a subosort in the order-sorted sense?
  Note 2 days later: I think we should go with the former; see last rule,
  which rewrites a Pgm into a Stmt.
- Should variables be sorted, i.e., X:Id, or we should use isSort membership
  patterns?  If we want to stay minimal, then the latter.  If we want
  to keep the KORE definitions human readable, then the former.  Also, note
  that almost any language used to implement backends should be able to deal
  with normal sorts / syntactic categories (as opposed to subsorts).
- Somewhat related to the above.  Should we enforce a strict sort discipline?
  I think we should.  That is, we should always enforce an operation f that
  takes arguments of sorts S1, S2, ... Sn to always take arguments of these
  sorts.  Subsorts of these should be injected.
- I believe injections should be declared strict.
***)

*** import "domains.kore"
*** inlined below

module INT
  syntax Int ::= plusInt(Int,Int)
  syntax Int ::= divInt(Int,Int)
endmodule

module MAP
  syntax Map ::= bind(K,K)                       [Map]   --- bind(Id,Int) ?
  syntax Map ::= .Map()                          [Map]
  syntax Map ::= map(Map,Map)                    [Map]
  axiom map(.Map(),M) = M                        [Map]
  axiom map(M,.Map()) = M                        [Map]
  axiom map(map(M1,M2),M3) = map(M1,map(M2,M3))  [Map]
  axiom map(M1,M2) = map(M2,M1)                  [Map]
endmodule

module DOMAINS
  import INT
  import MAP
endmodule

*** import "contexts.kore"
*** inlined below

module CONTEXTS
  syntax K ::= #context(K,K)
  syntax K ::= #context2(K,K,K)
  syntax K ::= #context3(K,K,K,K)
  axiom #context2(C,K1,K2) = #context(#context(C,K1),K2)
  axiom #context3(C,K1,K2,K3) = #context(#context2(C,K1,K2),K3)

  syntax K ::= #...(K)
  syntax K ::= #...2(K,K)
  syntax K ::= #...3(K,K)
  axiom #...(K) = \exists C . #context(C,K)
  axiom #...2(K1,K2) = \exists C . #context2(C,K1,K2)
  axiom #...3(K1,K2,K3) = \exists C . #context3(C,K1,K2,K3)

  *** #gamma to be always used with existential quantifier.
  *** For example, the empty context: \exists HOLE . #gamma(HOLE)
  syntax K ::= #gamma(K)
  axiom #context(\exists HOLE . #gamma(HOLE), K) = K
endmodule


module IMP-SYNTAX
  import DOMAINS-SYNTAX
  import CONTEXTS
  syntax AExp  ::= intAsAExp(Int)
  syntax AExp  ::= idAsAExp(Id)
  syntax AExp  ::= div(AExp,AExp)        [strict]
  axiom #context(\exists HOLE . #gamma(div(#context(C,HOLE),A2)),A1)
      = div(#context(C,A1),A2)           [strict(div,1)]
  axiom #context(\exists HOLE . #gamma(div(A1,#context(C,HOLE))),A2)
      = div(A1,#context(C,A2))           [strict(div,2)]
  syntax AExp  ::= plus(AExp,AExp)       [strict]
  axiom #context(\exists HOLE . #gamma(plus(#context(C,HOLE),A2)),A1)
      = plus(#context(C,A1),A2)          [strict(plus,1)]
  axiom #context(\exists HOLE . #gamma(plus(A1,#context(C,HOLE))),A2)
      = plus(A1,#context(C,A2))          [strict(plus,2)]
  syntax BExp  ::= boolAsBExp(Bool)
  syntax BExp  ::= leq(AExp,AExp)        [seqstrict]
  axiom #context(\exists HOLE . #gamma(leq(#context(C,HOLE),A2)),A1)
      = leq(#context(C,A1),A2)           [seqstrict(leq,1)]
  axiom isKResult(A1) = \true \implies
        #context(\exists HOLE . #gamma(leq(A1,#context(C,HOLE))),A2)
      = leq(A1,#context(C,A2))           [seqstrict(leq,2)]
  syntax BExp  ::= not(BExp)             [strict]
  axiom #context(\exists HOLE . #gamma(not(#context(C,HOLE)),B)
      = not(#context(C,B))               [strict(not,1)]
  syntax BExp  ::= and(BExp,BExp)        [strict(1)]
  axiom #context(\exists HOLE . #gamma(and(#context(C,HOLE),B2)),B1)
      = and(#context(C,B1),B2)           [strict(and,1)]
  syntax Block ::= emptyBlock()
  syntax Block ::= block(Stmt)
  syntax Stmt  ::= blockAsStmt(Block)
  syntax Stmt  ::= asgn(Id,AExp)         [strict(2)]
  axiom #context(\exists HOLE . #gamma(asgn(X,#context(C,HOLE))),A)
      = asgn(X,#context(C,A))            [strict(asgn,2)]
  syntax Stmt  ::= if(BExp,Block,Block)  [strict(1)]
  axiom #context(\exists HOLE . #gamma(if(#context(C,HOLE),S1,S2)),B)
      = if(#context(C,B),S1,S2)          [strict(if,1)]
  syntax Stmt  ::= while(BExp,Block)
  syntax Stmt  ::= seq(Stmt,Stmt)        [strict(1)]
  axiom #context(\exists HOLE . #gamma(seq(#context(C,HOLE),S2)),S1)
      = seq(#context(C,S1),S2)           [strict(seq,1)]
  syntax Pgm   ::= pgm(Ids,Stmt)
  syntax Ids   ::= idAsIds(Id)           [List]
  syntax Ids   ::= .Ids()                [List]
  syntax Ids   ::= comma(Ids,Ids)        [List]
  axiom comma(.Ids(),Ids) = Ids          [List]
  axiom comma(Ids,.Ids()) = Ids          [List]
  axiom comma(comma(Ids1,Ids2),Ids3) = comma(Ids1,comma(Ids2,Ids3))  [List]
endmodule


module IMP
  imports IMP-SYNTAX
  syntax KResult ::= Int | Bool

  configuration <Top color="yellow">
                  <k color="green"> $PGM:Pgm </k>
                  <state color="red"> .Map </state>
                </Top>

  syntax TopCell ::= top(KCell,StateCell)
  syntax TopCell ::= initTopCell(Map)


// AExp
--- below, we rely on the fact that the injection Id < Exp is strict.
  rule #...2(idAsAExp(X:Id) => intAsAExp(I), bind(X,I))
  rule #...(div(intAsExp(I1),intAsExp(I2) /\ \neg(I2 = 0))
            => intAsAExp(divInt(I1,I2)))
  rule #...(plus(intAsExp(I1),intAsExp(I2)) => intAsAExp(plusInt(I1,I2)))
// BExp
  rule #...(leq(intAsExp(I1),intAsExp(I2)) => boolAsBExp(leqInt(I1,I2)))
  rule #...(not(boolAsBExp(T)) => boolAsBExp(notBool(T)))
  rule #...(and(boolAsBExp(true),B) => B)
  rule #...(and(boolAsBExp(false),_) => boolAsBExp(false))
// Block
  rule #...(blockAsStmt(block(S)) => S)
// Stmt
  rule #...2(asgn(X,intAsAExp(I)) => blockAsStmt(emptyBlock()), bind(X,_=>I))
  rule #...(seq(blockAsStmt(emptyBlock()), S) => S)
  rule #...(if(boolAsBExp(true),S,_) => blockAsStmt(S))
  rule #...(if(boolAsBExp(false),_,S) => blockAsStmt(S))
  rule #...(while(B,S)
            => if(B,block(seq(blockAsStmt(S),while(B,S))),emptyBlock()))
// Pgm
  rule #...(pgm(comma(idAsIds(X),Xs) => Xs,_),
            state(map(Rho /\ in(X,keys(Rho)) = false,
			      .Map() => bind(X,Int("0")))))
  rule #...(pgmAsK(pgm(.Ids(),S)) => stmtAsK(S))
endmodule
