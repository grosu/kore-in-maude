***( Thoughts:
- Not sure how to deal with the sort K:
  Is it a super syntactic category of everything, with actual injections into
  it from each other user-defined syntactic category, or consider it a special
  sort where each user-defined sort is a subosort in the order-sorted sense?
  Note 2 days later: I think we should go with the former; see last rule,
  which rewrites a Pgm into a Stmt.
  Note 4 days later: Hm, we definitely need some way to allow polymorphic
  symbols; for example, the #context can have any sort as its second argument.
  One idea could be to consider K to be a polymorphic sort.
- Should variables be sorted, i.e., X:Id, or we should use isSort membership
  patterns?  If we want to stay minimal, then the latter.  If we want
  to keep the KORE definitions human readable, then the former.  Also, note
  that almost any language used to implement backends should be able to deal
  with normal sorts / syntactic categories (as opposed to subsorts).
- Somewhat related to the above.  Should we enforce a strict sort discipline?
  I think we should.  That is, we should always enforce an operation f that
  takes arguments of sorts S1, S2, ... Sn to always take arguments of these
  sorts.  Subsorts of these should be injected.
- I believe injections should be declared strict.
***)

*** import "domains.kore"
*** inlined below

module BOOL
  syntax Bool ::= true
  axiom true  = Bool("true")
  syntax Bool ::= false
  axiom false = Bool("false")
  syntax Bool ::= notBool(Bool)
endmodule

module INT
  import BOOL
  syntax Int ::= plusInt(Int,Int)
  syntax Int ::= divInt(Int,Int)
  syntax Bool ::= leqInt(Int,Int)
  syntax Int ::= 0
  axiom 0 = Int("0")
endmodule

module SET
  syntax Set ::= .Set()                                   [Set]
  syntax Set ::= kAsSet(K)                                [Set]
  syntax Set ::= union(Set,Set)                           [Set]
  syntax Bool ::= in(K,Set)                               [Set]
  axiom union(.Set(), S) = S                              [Set]
  axiom union(S1,S2) = union(S2,S1)                       [Set]
  axiom union(union(S1,S2),S3) = union(S1,union(S2,S3))   [Set]
  axiom union(S,S) = S                                    [Set]
  axiom in(K,union(kAsSet(K),S)) = true                   [Set]
  axiom \neg(K1 = K2) \implies
        in(K1,union(kAsSet(K2),S)) = in(K1,S)             [Set]
  axiom in(K1,.Set()) = false                             [Set]
endmodule

module MAP
  syntax Map ::= bind(K,K)                       [Map]   --- bind(Id,Int) ?
  syntax Map ::= .Map()                          [Map]
  syntax Map ::= map(Map,Map)                    [Map]
  axiom map(.Map(),M) = M                        [Map]
  axiom map(M,.Map()) = M                        [Map]
  axiom map(map(M1,M2),M3) = map(M1,map(M2,M3))  [Map]
  axiom map(M1,M2) = map(M2,M1)                  [Map]
endmodule

module DOMAINS
  import BOOL
  import INT
  import SET
  import MAP
endmodule

*** import "contexts.kore"
*** inlined below

module CONTEXTS
*** We want #context and #gamma to be polymorphic; which is why we may think
*** of K as a polymorphic sort.  Or we can add new notation for polymorphic
*** sorts or for polymorphic operations (like Maude does).
  syntax K ::= #context(K,K)
  syntax K ::= #context2(K,K,K)
  syntax K ::= #context3(K,K,K,K)
  axiom #context2(C,K1,K2) = #context(#context(C,K1),K2)
  axiom #context3(C,K1,K2,K3) = #context(#context2(C,K1,K2),K3)

  syntax K ::= #...(K)
  syntax K ::= #...2(K,K)
  syntax K ::= #...3(K,K)
  axiom #...(K) = \exists C . #context(C,K)
  axiom #...2(K1,K2) = \exists C . #context2(C,K1,K2)
  axiom #...3(K1,K2,K3) = \exists C . #context3(C,K1,K2,K3)

  *** #gamma to be always used with existential quantifier.
  *** For example, the empty context: \exists HOLE . #gamma(HOLE)
  syntax K ::= #gamma(K)
  axiom #context(\exists HOLE . #gamma(HOLE), K) = K
endmodule


module IMP-SYNTAX
  import DOMAINS-SYNTAX
  import CONTEXTS
  syntax AExp  ::= intAsAExp(Int)
  syntax AExp  ::= idAsAExp(Id)
  syntax AExp  ::= div(AExp,AExp)        [strict]
  axiom #context(\exists HOLE . #gamma(div(#context(C,HOLE),A2)),A1)
      = div(#context(C,A1),A2)           [strict(div,1)]
  axiom #context(\exists HOLE . #gamma(div(A1,#context(C,HOLE))),A2)
      = div(A1,#context(C,A2))           [strict(div,2)]
  syntax AExp  ::= plus(AExp,AExp)       [strict]
  axiom #context(\exists HOLE . #gamma(plus(#context(C,HOLE),A2)),A1)
      = plus(#context(C,A1),A2)          [strict(plus,1)]
  axiom #context(\exists HOLE . #gamma(plus(A1,#context(C,HOLE))),A2)
      = plus(A1,#context(C,A2))          [strict(plus,2)]
  syntax BExp  ::= boolAsBExp(Bool)
  syntax BExp  ::= leq(AExp,AExp)        [seqstrict]
  axiom #context(\exists HOLE . #gamma(leq(#context(C,HOLE),A2)),A1)
      = leq(#context(C,A1),A2)           [seqstrict(leq,1)]
  axiom isKResult(A1) = \true \implies
        #context(\exists HOLE . #gamma(leq(A1,#context(C,HOLE))),A2)
      = leq(A1,#context(C,A2))           [seqstrict(leq,2)]
  syntax BExp  ::= not(BExp)             [strict]
  axiom #context(\exists HOLE . #gamma(not(#context(C,HOLE)),B)
      = not(#context(C,B))               [strict(not,1)]
  syntax BExp  ::= and(BExp,BExp)        [strict(1)]
  axiom #context(\exists HOLE . #gamma(and(#context(C,HOLE),B2)),B1)
      = and(#context(C,B1),B2)           [strict(and,1)]
  syntax Block ::= emptyBlock()
  syntax Block ::= block(Stmt)
  syntax Stmt  ::= blockAsStmt(Block)
  syntax Stmt  ::= asgn(Id,AExp)         [strict(2)]
  axiom #context(\exists HOLE . #gamma(asgn(X,#context(C,HOLE))),A)
      = asgn(X,#context(C,A))            [strict(asgn,2)]
  syntax Stmt  ::= if(BExp,Block,Block)  [strict(1)]
  axiom #context(\exists HOLE . #gamma(if(#context(C,HOLE),S1,S2)),B)
      = if(#context(C,B),S1,S2)          [strict(if,1)]
  syntax Stmt  ::= while(BExp,Block)
  syntax Stmt  ::= seq(Stmt,Stmt)        [strict(1)]
  axiom #context(\exists HOLE . #gamma(seq(#context(C,HOLE),S2)),S1)
      = seq(#context(C,S1),S2)           [strict(seq,1)]
  syntax Pgm   ::= pgm(Ids,Stmt)
  syntax Ids   ::= idAsIds(Id)           [List]
  syntax Ids   ::= .Ids()                [List]
  syntax Ids   ::= comma(Ids,Ids)        [List]
  axiom comma(.Ids(),Ids) = Ids          [List]
  axiom comma(Ids,.Ids()) = Ids          [List]
  axiom comma(comma(Ids1,Ids2),Ids3) = comma(Ids1,comma(Ids2,Ids3))  [List]
endmodule


module IMP
  imports IMP-SYNTAX
  syntax KResult ::= Int | Bool

  syntax TopCell ::= top(KCell,StateCell)  [cfg]
  axiom #context(\exists HOLE . #gamma(top(#context(C,HOLE),Kc)),Sc)
      = top(#context(C,Kc),Sc)             [cfg(top,1)]
  axiom #context(\exists HOLE . #gamma(top(Kc,#context(C,HOLE))),Sc)
      = top(Kc,#context(C,Sc))             [cfg(top,2)]
  syntax KCell ::= k(K)                    [cfg]
  axiom #context(\exists HOLE . #gamma(k(#context(C,HOLE)),K)
      = k(#context(C,K))                   [cfg(k,1)]
  syntax StateCell ::= state(Map)          [cfg]
  axiom #context(\exists HOLE . #gamma(state(#context(C,HOLE)),M)
      = state(#context(C,M))               [cfg(state,1)]

  syntax TopCell ::= #krun(Pgm)
  axiom #krun(P) = top(k(P),state(.Map()))

*** AExp
--- below, we do NOT rely on the injection Id < Exp to be strict.
  rule #...2(idAsAExp(X) => intAsAExp(I), bind(X,I))
  rule \neg(I2 = Int("0")) \implies
       #...(div(intAsExp(I1),intAsExp(I2))
            => intAsAExp(divInt(I1,I2)))
  rule #...(plus(intAsExp(I1),intAsExp(I2)) => intAsAExp(plusInt(I1,I2)))
*** BExp
  rule #...(leq(intAsExp(I1),intAsExp(I2)) => boolAsBExp(leqInt(I1,I2)))
  rule #...(not(boolAsBExp(T)) => boolAsBExp(notBool(T)))
  rule #...(and(boolAsBExp(Bool("true")),B) => B)
  rule #...(and(boolAsBExp(Bool("false")),_) => boolAsBExp(Bool("false")))
*** Block
  rule #...(blockAsStmt(block(S)) => S)
*** Stmt
  rule #...2(asgn(X,intAsAExp(I)) => blockAsStmt(emptyBlock()), bind(X,_=>I))
  rule #...(seq(blockAsStmt(emptyBlock()), S) => S)
  rule #...(if(boolAsBExp(true),S,_) => blockAsStmt(S))
  rule #...(if(boolAsBExp(false),_,S) => blockAsStmt(S))
  rule #...(while(B,S)
            => if(B,block(seq(blockAsStmt(S),while(B,S))),emptyBlock()))
*** Pgm
  rule #...(pgm(comma(idAsIds(X),Xs) => Xs,_),
            state(map(Rho /\ in(X,keys(Rho)) = false,
			      .Map() => bind(X,Int("0")))))
*** Note that, without injections into K, the rule below changes the sort
*** of the LHS term.  That is OK (albeit tricky), because the only way to
*** complete the context below is with k(...) at the bottom, and the k
*** symbol is polymorphic.  However, to be safe, I am using explicit
*** injections.  We can actually allow and enforce the use of such injections
*** into polymorphic sorts as sanity checks.  Technically, for each symbol
*** sigma(S1,K,S2) polymorphic in K, we can assume an axiom
*** sigma(A1,sortAsK(T),A2) = sigma(A1,T,A2)
  rule #...(pgmAsK(pgm(.Ids(),S)) => stmtAsK(S))

endmodule
