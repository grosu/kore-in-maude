***( Thoughts:
- Not sure how to deal with the sort K:
  Is it a supersort of everything, and then have injections into it,
  from each user defined sort, or consider it a special sort where
  each user-defined sort is a subosort of it in the order-sorted
  algebra sense?
- Should variables be sorted, X:Id, or we should use isSort membership
  patterns?  If we want to stay minimal, then the latter.  If we want
  to keep the KORE definitions human readable, then the former.
***)

*** import "domains.kore"
*** inlined below

module MAP
  syntax Map ::= bind(K,K)                       [Map]
  syntax Map ::= .Map()                          [Map]
  syntax Map ::= map(Map,Map)                    [Map]
  axiom map(.Map(),M) = M                        [Map]
  axiom map(M,.Map()) = M                        [Map]
  axiom map(map(M1,M2),M3) = map(M1,map(M2,M3))  [Map]
  axiom map(M1,M2) = map(M2,M1)                  [Map]
endmodule

*** import "contexts.kore"
*** inlined below

module CONTEXTS
  syntax K ::= #context(K,K)
  syntax K ::= #context2(K,K,K)
  syntax K ::= #context3(K,K,K,K)
  axiom #context2(C,K1,K2) = #context(#context(C,K1),K2)
  axiom #context3(C,K1,K2,K3) = #context(#context2(C,K1,K2),K3)

  syntax K ::= #...(K)
  syntax K ::= #...2(K,K)
  syntax K ::= #...3(K,K)
  axiom #...(K) = \exists C . #context(C,K)
  axiom #...2(K1,K2) = \exists C . #context2(C,K1,K2)
  axiom #...3(K1,K2,K3) = \exists C . #context3(C,K1,K2,K3)

  *** #gamma to be always used with existential quantifier.
  *** For example, the empty context: \exists HOLE . #gamma(HOLE)
  syntax K ::= #gamma(K)
  axiom #context(\exists HOLE . #gamma(HOLE), K) = K
endmodule


module IMP-SYNTAX
  import DOMAINS-SYNTAX
  import CONTEXTS
  syntax AExp  ::= intAsAExp(Int)
  syntax AExp  ::= idAsAExp(Id)
  syntax AExp  ::= div(AExp,AExp)        [strict]
  axiom #context(\exists HOLE . #gamma(div(#context(C,HOLE),A2)),A1)
      = div(#context(C,A1),A2)           [strict(div,1)]
  axiom #context(\exists HOLE . #gamma(div(A1,#context(C,HOLE))),A2)
      = div(A1,#context(C,A2))           [strict(div,2)]
  syntax AExp  ::= plus(AExp,AExp)       [strict]
  axiom #context(\exists HOLE . #gamma(plus(#context(C,HOLE),A2)),A1)
      = plus(#context(C,A1),A2)          [strict(plus,1)]
  axiom #context(\exists HOLE . #gamma(plus(A1,#context(C,HOLE))),A2)
      = plus(A1,#context(C,A2))          [strict(plus,2)]
  syntax BExp  ::= boolAsBExp(Bool)
  syntax BExp  ::= leq(AExp,AExp)        [seqstrict]
  axiom #context(\exists HOLE . #gamma(leq(#context(C,HOLE),A2)),A1)
      = leq(#context(C,A1),A2)           [seqstrict(leq,1)]
  axiom isKResult(A1) = \true \implies
        #context(\exists HOLE . #gamma(leq(A1,#context(C,HOLE))),A2)
      = leq(A1,#context(C,A2))           [seqstrict(leq,2)]
  syntax BExp  ::= not(BExp)             [strict]
  axiom #context(\exists HOLE . #gamma(not(#context(C,HOLE)),B)
      = not(#context(C,B))               [strict(not,1)]
  syntax BExp  ::= and(BExp,BExp)        [strict(1)]
  axiom #context(\exists HOLE . #gamma(and(#context(C,HOLE),B2)),B1)
      = and(#context(C,B1),B2)           [strict(and,1)]
  syntax Block ::= empty()
  syntax Block ::= block(Stmt)
  syntax Stmt  ::= blockAsStmt(Block)
  syntax Stmt  ::= asgn(Id,AExp)         [strict(2)]
  axiom #context(\exists HOLE . #gamma(asgn(X,#context(C,HOLE))),A)
      = asgn(X,#context(C,A))            [strict(asgn,2)]
  syntax Stmt  ::= if(BExp,Block,Block)  [strict(1)]
  axiom #context(\exists HOLE . #gamma(if(#context(C,HOLE),S1,S2)),B)
      = if(#context(C,B),S1,S2)          [strict(if,1)]
  syntax Stmt  ::= while(BExp,Block)
  syntax Stmt  ::= seq(Stmt,Stmt)        [strict(1)]
  axiom #context(\exists HOLE . #gamma(seq(#context(C,HOLE),S2)),S1)
      = seq(#context(C,S1),S2)           [strict(seq,1)]
  syntax Pgm   ::= pgm(Ids,Stmt)
  syntax Ids   ::= idAsIds(Id)           [List]
  syntax Ids   ::= .Ids()                [List]
  syntax Ids   ::= comma(Ids,Ids)        [List]
  axiom comma(.Ids(),Ids) = Ids          [List]
  axiom comma(Ids,.Ids()) = Ids          [List]
  axiom comma(comma(Ids1,Ids2),Ids3) = comma(Ids1,comma(Ids2,Ids3))  [List]
endmodule


module IMP
  imports IMP-SYNTAX
  syntax KResult ::= Int | Bool

  configuration <T color="yellow">
                  <k color="green"> $PGM:Pgm </k>
                  <state color="red"> .Map </state>
                </T>

// AExp
  rule #...2(X:Id => I, bind(X,I))
  rule I1 / I2 => I1 /Int I2  requires I2 =/=Int 0
  rule I1 + I2 => I1 +Int I2
// BExp
  rule I1 <= I2 => I1 <=Int I2
  rule ! T => notBool T
  rule true && B => B
  rule false && _ => false
// Block
  rule {S} => S
// Stmt
  rule X = I:Int; => {} ... X |-> (_ => I)
  rule {} S => S
  rule if (true)  S else _ => S
  rule if (false) _ else S => S
  rule while (B) S => if (B) {S while (B) S} else {}  [structural]
// Pgm
  rule int (X,Xs => Xs);_ ... <state> Rho:Map (.Map => X|->0) </state>
    requires notBool (X in keys(Rho))
  rule int .Ids; S => S  [structural]
endmodule
