in kore
in imp-tokens

mod IMP is
  including IMP-TOKENS .
  op ??? : -> Sort .
endm

parse

module ID
  syntax Id []
endmodule []
 
module BOOL
  syntax Bool []
  syntax Bool ::= true() []
  axiom \equal(true(), bool("true")) []
  syntax Bool ::= false() []
  axiom \equal(false(), bool("false")) []
  syntax Bool ::= not@BOOL(Bool) []
endmodule []
 
module INT
  import BOOL []
  syntax Int []
  syntax Int ::= plus@INT(Int,Int) []
  syntax Int ::= div@INT(Int,Int) []
  syntax Bool ::= leq@INT(Int,Int) []
  syntax Int ::= 0() []
  axiom \equal(0(), int("0")) []
endmodule []
 
module SET
  syntax Set [set()]
  syntax Set ::= .Set() [set()]
  syntax Set ::= kAsSet(K) [set()]
  syntax Set ::= comma@SET(Set,Set) [set()]
  syntax Bool ::= in(K,Set) [set()]
  axiom \equal(comma@SET(.Set(), S : ???), S : ???) [set()]
  axiom \equal(comma@SET(S1 : ???, S2 : ???), comma@SET(S2 : ???, S1 : ???)) [set()]
  axiom \equal(comma@SET(comma@SET(S1 : ???, S2 : ???), S3 : ???), comma@SET(S1 : ???, comma@SET(S2 : ???, S3 : ???))) [set()]
  axiom \equal(comma@SET(S : ???, S : ???), S : ???) [set()]
  axiom \equal(in(K1 : ???, comma@SET(kAsSet(K1 : ???), S : ???)), true()) [set()]
  axiom \implies(\not(\equal(K1 : ???, K2 : ???)), \equal(in(K1 : ???, comma@SET(kAsSet(K2 : ???), S : ???)), in(K1 : ???, S :
    ???))) [set()]
  axiom \equal(in(K1 : ???, .Set()), false()) [set()]
endmodule []
 
module MAP
  import SET []
  syntax Map [map()]
  syntax Map ::= bind(K,K) [map()]
  syntax Map ::= .Map() [map()]
  syntax Map ::= comma@MAP(Map,Map) [map()]
  syntax Set ::= keys(Map) [map()]
  axiom \equal(comma@MAP(.Map(), M : ???), M : ???) [map()]
  axiom \equal(comma@MAP(M : ???, .Map()), M : ???) [map()]
  axiom \equal(comma@MAP(comma@MAP(M1 : ???, M2 : ???), M3 : ???), comma@MAP(M1 : ???, comma@MAP(M2 : ???, M3 : ???))) [map()]
  axiom \equal(comma@MAP(M1 : ???, M2 : ???), comma@MAP(M2 : ???, M1 : ???)) [map()]
endmodule []
 
module DOMAINS
  import ID []
  import BOOL []
  import INT []
  import SET []
  import MAP []
endmodule []
 
module K
  syntax KResult []
  syntax K []
  syntax K ::= kResultAsK(KResult) []
endmodule []
 
module CONTEXTS
  import K []
  syntax K ::= #context(K,K) []
  syntax K ::= #context2(K,K,K) []
  syntax K ::= #context3(K,K,K,K) []
  axiom \equal(#context2(C : ???, K1 : ???, K2 : ???), #context(#context(C : ???, K1 : ???), K2 : ???)) []
  axiom \equal(#context3(C : ???, K1 : ???, K2 : ???, K3 : ???), #context(#context2(C : ???, K1 : ???, K2 : ???), K3 : ???)) []
  syntax K ::= #...(K) []
  syntax K ::= #...2(K,K) []
  syntax K ::= #...3(K,K) []
  axiom \equal(#...(K1 : ???), \exists(C : ???, #context(C : ???, K1 : ???))) []
  axiom \equal(#...2(K1 : ???, K2 : ???), \exists(C : ???, #context2(C : ???, K1 : ???, K2 : ???))) []
  axiom \equal(#...3(K1 : ???, K2 : ???, K3 : ???), \exists(C : ???, #context3(C : ???, K1 : ???, K2 : ???, K3 : ???))) []
  syntax K ::= #gamma(K) []
  axiom \equal(#context(\exists(HOLE : ???, #gamma(HOLE : ???)), K1 : ???), K1 : ???) []
endmodule []
 
module IMP-SYNTAX
  import DOMAINS []
  import CONTEXTS []
  syntax AExp []
  syntax AExp ::= intAsAExp(Int) []
  syntax AExp ::= idAsAExp(Id) []
  syntax AExp ::= div(AExp,AExp) [strict()]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(div(#context(C : ???, HOLE : ???), A2 : ???))), A1 : ???), div(#context(C :
    ???, A1 : ???), A2 : ???)) [strict(div(), 1())]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(div(A1 : ???, #context(C : ???, HOLE : ???)))), A2 : ???), div(A1 : ???,
    #context(C : ???, A2 : ???))) [strict(div(), 2())]
  syntax AExp ::= plus(AExp,AExp) [strict()]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(plus(#context(C : ???, HOLE : ???), A2 : ???))), A1 : ???), plus(#context(C
    : ???, A1 : ???), A2 : ???)) [strict(plus(), 1())]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(plus(A1 : ???, #context(C : ???, HOLE : ???)))), A2 : ???), plus(A1 : ???,
    #context(C : ???, A2 : ???))) [strict(plus(), 2())]
  syntax BExp []
  syntax BExp ::= boolAsBExp(Bool) []
  syntax BExp ::= leq(AExp,AExp) [seqstrict()]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(leq(#context(C : ???, HOLE : ???), A2 : ???))), A1 : ???), leq(#context(C :
    ???, A1 : ???), A2 : ???)) [seqstrict(leq(), 1())]
  axiom \implies(\equal(isKResult(A1 : ???), \true), \equal(#context(\exists(HOLE : ???, #gamma(leq(A1 : ???, #context(C : ???,
    HOLE : ???)))), A2 : ???), leq(A1 : ???, #context(C : ???, A2 : ???)))) [seqstrict(leq(), 2())]
  syntax BExp ::= not(BExp) [strict()]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(not(#context(C : ???, HOLE : ???)))), B : ???), not(#context(C : ???, B :
    ???))) [strict(not(), 1())]
  syntax BExp ::= and(BExp,BExp) [strict(1())]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(and(#context(C : ???, HOLE : ???), B2 : ???))), B1 : ???), and(#context(C :
    ???, B1 : ???), B2 : ???)) [strict(and(), 1())]
  syntax Block []
  syntax Block ::= emptyBlock() []
  syntax Block ::= block(Stmt) []
  syntax Stmt []
  syntax Stmt ::= blockAsStmt(Block) []
  syntax Stmt ::= asgn(Id,AExp) [strict(2())]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(asgn(X : ???, #context(C : ???, HOLE : ???)))), A : ???), asgn(X : ???,
    #context(C : ???, A : ???))) [strict(asgn(), 2())]
  syntax Stmt ::= if(BExp,Block,Block) [strict(1())]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(if(#context(C : ???, HOLE : ???), S1 : ???, S2 : ???))), B : ???), if(
    #context(C : ???, B : ???), S1 : ???, S2 : ???)) [strict(if(), 1())]
  syntax Stmt ::= while(BExp,Block) []
  syntax Stmt ::= seq(Stmt,Stmt) [strict(1())]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(seq(#context(C : ???, HOLE : ???), S2 : ???))), S1 : ???), seq(#context(C :
    ???, S1 : ???), S2 : ???)) [strict(seq(), 1())]
  syntax Pgm []
  syntax Pgm ::= pgm(Ids,Stmt) []
  syntax Ids []
  syntax Ids ::= idAsIds(Id) [list()]
  syntax Ids ::= .Ids() [list()]
  syntax Ids ::= comma(Ids,Ids) [list()]
  axiom \equal(comma(.Ids(), Ids1 : ???), Ids1 : ???) [list()]
  axiom \equal(comma(Ids1 : ???, .Ids()), Ids1 : ???) [list()]
  axiom \equal(comma(comma(Ids1 : ???, Ids2 : ???), Ids3 : ???), comma(Ids1 : ???, comma(Ids2 : ???, Ids3 : ???))) [list()]
endmodule []
 
module IMP
  import IMP-SYNTAX []
  syntax KResult ::= intAsKResult(Int) []
  syntax KResult ::= boolAsKResult(Bool) []
  syntax TopCell [cfg()]
  syntax TopCell ::= top(KCell,StateCell) [cfg()]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(top(#context(C : ???, HOLE : ???), Sc : ???))), Kc : ???), top(#context(C :
    ???, Kc : ???), Sc : ???)) [cfg(top(), 1())]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(top(Kc : ???, #context(C : ???, HOLE : ???)))), Sc : ???), top(Kc : ???,
    #context(C : ???, Sc : ???))) [cfg(top(), 2())]
  syntax KCell [cfg()]
  syntax KCell ::= k(K) [cfg()]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(k(#context(C : ???, HOLE : ???)))), K1 : ???), k(#context(C : ???, K1 :
    ???))) [cfg(k(), 1())]
  syntax StateCell [cfg()]
  syntax StateCell ::= state(Map) [cfg()]
  axiom \equal(#context(\exists(HOLE : ???, #gamma(state(#context(C : ???, HOLE : ???)))), M : ???), state(#context(C : ???, M
    : ???))) [cfg(state(), 1())]
  syntax TopCell ::= #krun(Pgm) []
  axiom \equal(#krun(P : ???), top(k(P : ???), state(.Map()))) []
  rule #...2(\rewrite(idAsAExp(X : ???), intAsAExp(I : ???)), bind(X : ???, I : ???)) []
  rule \implies(\not(\equal(I2 : ???, 0())), #...(\rewrite(div(intAsAExp(I1 : ???), intAsAExp(I2 : ???)), intAsAExp(div@INT(I1
    : ???, I2 : ???))))) []
  rule #...(\rewrite(plus(intAsAExp(I1 : ???), intAsAExp(I2 : ???)), intAsAExp(plus@INT(I1 : ???, I2 : ???)))) []
  rule #...(\rewrite(leq(intAsAExp(I1 : ???), intAsAExp(I2 : ???)), boolAsBExp(leq@INT(I1 : ???, I2 : ???)))) []
  rule #...(\rewrite(not(boolAsBExp(T : ???)), boolAsBExp(not@BOOL(T : ???)))) []
  rule #...(\rewrite(and(boolAsBExp(true()), B : ???), B : ???)) []
  rule #...(\rewrite(and(boolAsBExp(false()), _ : ???), boolAsBExp(false()))) []
  rule #...(\rewrite(blockAsStmt(block(S : ???)), S : ???)) []
  rule #...2(\rewrite(asgn(X : ???, intAsAExp(I : ???)), blockAsStmt(emptyBlock())), bind(X : ???, \rewrite(_ : ???, I : ???)))
    []
  rule #...(\rewrite(seq(blockAsStmt(emptyBlock()), S : ???), S : ???)) []
  rule #...(\rewrite(if(boolAsBExp(true()), S : ???, _ : ???), blockAsStmt(S : ???))) []
  rule #...(\rewrite(if(boolAsBExp(false()), _ : ???, S : ???), blockAsStmt(S : ???))) []
  rule #...(\rewrite(while(B : ???, S : ???), if(B : ???, block(seq(blockAsStmt(S : ???), while(B : ???, S : ???))),
    emptyBlock()))) []
  rule #...(pgm(\rewrite(comma(idAsIds(X : ???), Xs : ???), Xs : ???), _ : ???), state(comma@MAP(\equal(\and(M : ???, in(X :
    ???, keys(M : ???))), false()), \rewrite(.Map(), bind(X : ???, 0()))))) []
  rule #...(\rewrite(pgmAsK(pgm(.Ids(), S : Stmt)), stmtAsK(S : ???))) []
endmodule []

  .

q

